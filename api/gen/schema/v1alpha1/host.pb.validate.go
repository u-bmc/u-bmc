// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: schema/v1alpha1/host.proto

package schemav1alpha1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on Host with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Host) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Host with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in HostMultiError, or nil if none found.
func (m *Host) ValidateAll() error {
	return m.validate(true)
}

func (m *Host) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if all {
		switch v := interface{}(m.GetAsset()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, HostValidationError{
					field:  "Asset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, HostValidationError{
					field:  "Asset",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAsset()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return HostValidationError{
				field:  "Asset",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Metadata

	if m.Description != nil {
		// no validation rules for Description
	}

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.CurrentState != nil {
		// no validation rules for CurrentState
	}

	if m.RequestedTransition != nil {
		// no validation rules for RequestedTransition
	}

	if m.LastRestartCause != nil {
		// no validation rules for LastRestartCause
	}

	if m.Location != nil {

		if all {
			switch v := interface{}(m.GetLocation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "Location",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "Location",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Firmware != nil {

		if all {
			switch v := interface{}(m.GetFirmware()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "Firmware",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "Firmware",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFirmware()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostValidationError{
					field:  "Firmware",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.OperatingSystem != nil {

		if all {
			switch v := interface{}(m.GetOperatingSystem()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "OperatingSystem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "OperatingSystem",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetOperatingSystem()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostValidationError{
					field:  "OperatingSystem",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.BootProgress != nil {

		if all {
			switch v := interface{}(m.GetBootProgress()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "BootProgress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "BootProgress",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBootProgress()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostValidationError{
					field:  "BootProgress",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.LastReboot != nil {

		if all {
			switch v := interface{}(m.GetLastReboot()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "LastReboot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "LastReboot",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastReboot()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostValidationError{
					field:  "LastReboot",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.UpdatedAt != nil {

		if all {
			switch v := interface{}(m.GetUpdatedAt()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostValidationError{
						field:  "UpdatedAt",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUpdatedAt()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostValidationError{
					field:  "UpdatedAt",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HostMultiError(errors)
	}

	return nil
}

// HostMultiError is an error wrapping multiple validation errors returned by
// Host.ValidateAll() if the designated constraints aren't met.
type HostMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostMultiError) AllErrors() []error { return m }

// HostValidationError is the validation error returned by Host.Validate if the
// designated constraints aren't met.
type HostValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostValidationError) ErrorName() string { return "HostValidationError" }

// Error satisfies the builtin error interface
func (e HostValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHost.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostValidationError{}

// Validate checks the field values on HostOperatingSystem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HostOperatingSystem) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostOperatingSystem with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostOperatingSystemMultiError, or nil if none found.
func (m *HostOperatingSystem) ValidateAll() error {
	return m.validate(true)
}

func (m *HostOperatingSystem) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Name != nil {
		// no validation rules for Name
	}

	if m.Version != nil {
		// no validation rules for Version
	}

	if m.Distribution != nil {
		// no validation rules for Distribution
	}

	if m.Architecture != nil {
		// no validation rules for Architecture
	}

	if m.KernelVersion != nil {
		// no validation rules for KernelVersion
	}

	if m.BuildNumber != nil {
		// no validation rules for BuildNumber
	}

	if m.InstallationDate != nil {

		if all {
			switch v := interface{}(m.GetInstallationDate()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostOperatingSystemValidationError{
						field:  "InstallationDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostOperatingSystemValidationError{
						field:  "InstallationDate",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetInstallationDate()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostOperatingSystemValidationError{
					field:  "InstallationDate",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.LastBootTime != nil {

		if all {
			switch v := interface{}(m.GetLastBootTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostOperatingSystemValidationError{
						field:  "LastBootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostOperatingSystemValidationError{
						field:  "LastBootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastBootTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostOperatingSystemValidationError{
					field:  "LastBootTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.Status != nil {
		// no validation rules for Status
	}

	if len(errors) > 0 {
		return HostOperatingSystemMultiError(errors)
	}

	return nil
}

// HostOperatingSystemMultiError is an error wrapping multiple validation
// errors returned by HostOperatingSystem.ValidateAll() if the designated
// constraints aren't met.
type HostOperatingSystemMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostOperatingSystemMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostOperatingSystemMultiError) AllErrors() []error { return m }

// HostOperatingSystemValidationError is the validation error returned by
// HostOperatingSystem.Validate if the designated constraints aren't met.
type HostOperatingSystemValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostOperatingSystemValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostOperatingSystemValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostOperatingSystemValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostOperatingSystemValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostOperatingSystemValidationError) ErrorName() string {
	return "HostOperatingSystemValidationError"
}

// Error satisfies the builtin error interface
func (e HostOperatingSystemValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostOperatingSystem.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostOperatingSystemValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostOperatingSystemValidationError{}

// Validate checks the field values on BootProgress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *BootProgress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BootProgress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in BootProgressMultiError, or
// nil if none found.
func (m *BootProgress) ValidateAll() error {
	return m.validate(true)
}

func (m *BootProgress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Stage

	// no validation rules for ProgressPercent

	if m.LastBootTime != nil {

		if all {
			switch v := interface{}(m.GetLastBootTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BootProgressValidationError{
						field:  "LastBootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BootProgressValidationError{
						field:  "LastBootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastBootTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BootProgressValidationError{
					field:  "LastBootTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BootProgressMultiError(errors)
	}

	return nil
}

// BootProgressMultiError is an error wrapping multiple validation errors
// returned by BootProgress.ValidateAll() if the designated constraints aren't met.
type BootProgressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BootProgressMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BootProgressMultiError) AllErrors() []error { return m }

// BootProgressValidationError is the validation error returned by
// BootProgress.Validate if the designated constraints aren't met.
type BootProgressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BootProgressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BootProgressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BootProgressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BootProgressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BootProgressValidationError) ErrorName() string { return "BootProgressValidationError" }

// Error satisfies the builtin error interface
func (e BootProgressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBootProgress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BootProgressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BootProgressValidationError{}

// Validate checks the field values on HostRebootInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HostRebootInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostRebootInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HostRebootInfoMultiError,
// or nil if none found.
func (m *HostRebootInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *HostRebootInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.LastRebootTime != nil {

		if all {
			switch v := interface{}(m.GetLastRebootTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostRebootInfoValidationError{
						field:  "LastRebootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostRebootInfoValidationError{
						field:  "LastRebootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLastRebootTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostRebootInfoValidationError{
					field:  "LastRebootTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.RebootCause != nil {
		// no validation rules for RebootCause
	}

	if m.RebootCount != nil {
		// no validation rules for RebootCount
	}

	if m.Uptime != nil {

		if all {
			switch v := interface{}(m.GetUptime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostRebootInfoValidationError{
						field:  "Uptime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostRebootInfoValidationError{
						field:  "Uptime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetUptime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostRebootInfoValidationError{
					field:  "Uptime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if m.BootTime != nil {

		if all {
			switch v := interface{}(m.GetBootTime()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostRebootInfoValidationError{
						field:  "BootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostRebootInfoValidationError{
						field:  "BootTime",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetBootTime()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostRebootInfoValidationError{
					field:  "BootTime",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HostRebootInfoMultiError(errors)
	}

	return nil
}

// HostRebootInfoMultiError is an error wrapping multiple validation errors
// returned by HostRebootInfo.ValidateAll() if the designated constraints
// aren't met.
type HostRebootInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostRebootInfoMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostRebootInfoMultiError) AllErrors() []error { return m }

// HostRebootInfoValidationError is the validation error returned by
// HostRebootInfo.Validate if the designated constraints aren't met.
type HostRebootInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostRebootInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostRebootInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostRebootInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostRebootInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostRebootInfoValidationError) ErrorName() string { return "HostRebootInfoValidationError" }

// Error satisfies the builtin error interface
func (e HostRebootInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostRebootInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostRebootInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostRebootInfoValidationError{}

// Validate checks the field values on GetHostRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GetHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GetHostRequestMultiError,
// or nil if none found.
func (m *GetHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch v := m.Identifier.(type) {
	case *GetHostRequest_HostId:
		if v == nil {
			err := GetHostRequestValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for HostId
	case *GetHostRequest_Name:
		if v == nil {
			err := GetHostRequestValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Name
	case *GetHostRequest_Type:
		if v == nil {
			err := GetHostRequestValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for Type
	case *GetHostRequest_State:
		if v == nil {
			err := GetHostRequestValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
		// no validation rules for State
	case *GetHostRequest_Location:
		if v == nil {
			err := GetHostRequestValidationError{
				field:  "Identifier",
				reason: "oneof value cannot be a typed-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if all {
			switch v := interface{}(m.GetLocation()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetHostRequestValidationError{
						field:  "Location",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetHostRequestValidationError{
						field:  "Location",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetLocation()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetHostRequestValidationError{
					field:  "Location",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	default:
		_ = v // ensures v is used
	}

	if m.FieldMask != nil {

		if all {
			switch v := interface{}(m.GetFieldMask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetHostRequestValidationError{
						field:  "FieldMask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetHostRequestValidationError{
						field:  "FieldMask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFieldMask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetHostRequestValidationError{
					field:  "FieldMask",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetHostRequestMultiError(errors)
	}

	return nil
}

// GetHostRequestMultiError is an error wrapping multiple validation errors
// returned by GetHostRequest.ValidateAll() if the designated constraints
// aren't met.
type GetHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostRequestMultiError) AllErrors() []error { return m }

// GetHostRequestValidationError is the validation error returned by
// GetHostRequest.Validate if the designated constraints aren't met.
type GetHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostRequestValidationError) ErrorName() string { return "GetHostRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostRequestValidationError{}

// Validate checks the field values on GetHostResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *GetHostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GetHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// GetHostResponseMultiError, or nil if none found.
func (m *GetHostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GetHostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetHosts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GetHostResponseValidationError{
						field:  fmt.Sprintf("Hosts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GetHostResponseValidationError{
						field:  fmt.Sprintf("Hosts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GetHostResponseValidationError{
					field:  fmt.Sprintf("Hosts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return GetHostResponseMultiError(errors)
	}

	return nil
}

// GetHostResponseMultiError is an error wrapping multiple validation errors
// returned by GetHostResponse.ValidateAll() if the designated constraints
// aren't met.
type GetHostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetHostResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetHostResponseMultiError) AllErrors() []error { return m }

// GetHostResponseValidationError is the validation error returned by
// GetHostResponse.Validate if the designated constraints aren't met.
type GetHostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetHostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetHostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetHostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetHostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetHostResponseValidationError) ErrorName() string { return "GetHostResponseValidationError" }

// Error satisfies the builtin error interface
func (e GetHostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetHostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetHostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetHostResponseValidationError{}

// Validate checks the field values on ListHostsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListHostsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHostsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListHostsRequestMultiError, or nil if none found.
func (m *ListHostsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHostsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Type != nil {
		// no validation rules for Type
	}

	if m.State != nil {
		// no validation rules for State
	}

	if m.FieldMask != nil {

		if all {
			switch v := interface{}(m.GetFieldMask()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListHostsRequestValidationError{
						field:  "FieldMask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListHostsRequestValidationError{
						field:  "FieldMask",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetFieldMask()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListHostsRequestValidationError{
					field:  "FieldMask",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListHostsRequestMultiError(errors)
	}

	return nil
}

// ListHostsRequestMultiError is an error wrapping multiple validation errors
// returned by ListHostsRequest.ValidateAll() if the designated constraints
// aren't met.
type ListHostsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHostsRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHostsRequestMultiError) AllErrors() []error { return m }

// ListHostsRequestValidationError is the validation error returned by
// ListHostsRequest.Validate if the designated constraints aren't met.
type ListHostsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHostsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHostsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHostsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHostsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHostsRequestValidationError) ErrorName() string { return "ListHostsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListHostsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHostsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHostsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHostsRequestValidationError{}

// Validate checks the field values on ListHostsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ListHostsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHostsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListHostsResponseMultiError, or nil if none found.
func (m *ListHostsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHostsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetHosts() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListHostsResponseValidationError{
						field:  fmt.Sprintf("Hosts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListHostsResponseValidationError{
						field:  fmt.Sprintf("Hosts[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListHostsResponseValidationError{
					field:  fmt.Sprintf("Hosts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListHostsResponseMultiError(errors)
	}

	return nil
}

// ListHostsResponseMultiError is an error wrapping multiple validation errors
// returned by ListHostsResponse.ValidateAll() if the designated constraints
// aren't met.
type ListHostsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHostsResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHostsResponseMultiError) AllErrors() []error { return m }

// ListHostsResponseValidationError is the validation error returned by
// ListHostsResponse.Validate if the designated constraints aren't met.
type ListHostsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHostsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHostsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHostsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHostsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHostsResponseValidationError) ErrorName() string {
	return "ListHostsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListHostsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHostsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHostsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHostsResponseValidationError{}

// Validate checks the field values on UpdateHostRequest with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UpdateHostRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateHostRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateHostRequestMultiError, or nil if none found.
func (m *UpdateHostRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateHostRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostId

	if all {
		switch v := interface{}(m.GetHost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateHostRequestValidationError{
					field:  "Host",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateHostRequestValidationError{
					field:  "Host",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateHostRequestValidationError{
				field:  "Host",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFieldMask()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateHostRequestValidationError{
					field:  "FieldMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateHostRequestValidationError{
					field:  "FieldMask",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFieldMask()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateHostRequestValidationError{
				field:  "FieldMask",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateHostRequestMultiError(errors)
	}

	return nil
}

// UpdateHostRequestMultiError is an error wrapping multiple validation errors
// returned by UpdateHostRequest.ValidateAll() if the designated constraints
// aren't met.
type UpdateHostRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateHostRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateHostRequestMultiError) AllErrors() []error { return m }

// UpdateHostRequestValidationError is the validation error returned by
// UpdateHostRequest.Validate if the designated constraints aren't met.
type UpdateHostRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateHostRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateHostRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateHostRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateHostRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateHostRequestValidationError) ErrorName() string {
	return "UpdateHostRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateHostRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateHostRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateHostRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateHostRequestValidationError{}

// Validate checks the field values on UpdateHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *UpdateHostResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UpdateHostResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UpdateHostResponseMultiError, or nil if none found.
func (m *UpdateHostResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *UpdateHostResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetHost()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UpdateHostResponseValidationError{
					field:  "Host",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UpdateHostResponseValidationError{
					field:  "Host",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHost()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UpdateHostResponseValidationError{
				field:  "Host",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UpdateHostResponseMultiError(errors)
	}

	return nil
}

// UpdateHostResponseMultiError is an error wrapping multiple validation errors
// returned by UpdateHostResponse.ValidateAll() if the designated constraints
// aren't met.
type UpdateHostResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateHostResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateHostResponseMultiError) AllErrors() []error { return m }

// UpdateHostResponseValidationError is the validation error returned by
// UpdateHostResponse.Validate if the designated constraints aren't met.
type UpdateHostResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateHostResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateHostResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateHostResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateHostResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateHostResponseValidationError) ErrorName() string {
	return "UpdateHostResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateHostResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateHostResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateHostResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateHostResponseValidationError{}

// Validate checks the field values on HostChangeStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HostChangeStateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostChangeStateRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostChangeStateRequestMultiError, or nil if none found.
func (m *HostChangeStateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *HostChangeStateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HostId

	// no validation rules for Transition

	// no validation rules for Metadata

	if m.Force != nil {
		// no validation rules for Force
	}

	if len(errors) > 0 {
		return HostChangeStateRequestMultiError(errors)
	}

	return nil
}

// HostChangeStateRequestMultiError is an error wrapping multiple validation
// errors returned by HostChangeStateRequest.ValidateAll() if the designated
// constraints aren't met.
type HostChangeStateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostChangeStateRequestMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostChangeStateRequestMultiError) AllErrors() []error { return m }

// HostChangeStateRequestValidationError is the validation error returned by
// HostChangeStateRequest.Validate if the designated constraints aren't met.
type HostChangeStateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostChangeStateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostChangeStateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostChangeStateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostChangeStateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostChangeStateRequestValidationError) ErrorName() string {
	return "HostChangeStateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e HostChangeStateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostChangeStateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostChangeStateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostChangeStateRequestValidationError{}

// Validate checks the field values on HostChangeStateResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *HostChangeStateResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HostChangeStateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// HostChangeStateResponseMultiError, or nil if none found.
func (m *HostChangeStateResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *HostChangeStateResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Success

	// no validation rules for Metadata

	if m.ErrorMessage != nil {
		// no validation rules for ErrorMessage
	}

	if m.CurrentState != nil {
		// no validation rules for CurrentState
	}

	if m.TransitionId != nil {
		// no validation rules for TransitionId
	}

	if m.EstimatedCompletion != nil {

		if all {
			switch v := interface{}(m.GetEstimatedCompletion()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, HostChangeStateResponseValidationError{
						field:  "EstimatedCompletion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, HostChangeStateResponseValidationError{
						field:  "EstimatedCompletion",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetEstimatedCompletion()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return HostChangeStateResponseValidationError{
					field:  "EstimatedCompletion",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return HostChangeStateResponseMultiError(errors)
	}

	return nil
}

// HostChangeStateResponseMultiError is an error wrapping multiple validation
// errors returned by HostChangeStateResponse.ValidateAll() if the designated
// constraints aren't met.
type HostChangeStateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HostChangeStateResponseMultiError) Error() string {
	msgs := make([]string, 0, len(m))
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HostChangeStateResponseMultiError) AllErrors() []error { return m }

// HostChangeStateResponseValidationError is the validation error returned by
// HostChangeStateResponse.Validate if the designated constraints aren't met.
type HostChangeStateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HostChangeStateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HostChangeStateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HostChangeStateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HostChangeStateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HostChangeStateResponseValidationError) ErrorName() string {
	return "HostChangeStateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e HostChangeStateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHostChangeStateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HostChangeStateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HostChangeStateResponseValidationError{}
